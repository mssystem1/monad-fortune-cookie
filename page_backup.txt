// /app/page.tsx
'use client';

import { useEffect, useMemo, useRef, useState } from 'react';
import { useAccount, usePublicClient, useWalletClient } from 'wagmi';
import { ConnectButton } from '@rainbow-me/rainbowkit';
import { parseAbiItem, parseEventLogs, type Abi } from 'viem';
import rawAbi from '../abi/FortuneCookiesAI.json';
import { monadTestnet } from '../lib/chain';

// ── Config ─────────────────────────────────────────────────────────────────────
const CONTRACT = (() => {
  const v = process.env.NEXT_PUBLIC_COOKIE_ADDRESS as `0x${string}` | undefined;
  if (!v) throw new Error('NEXT_PUBLIC_COOKIE_ADDRESS is not set in .env.local');
  return v;
})();

// Optional: set your contract’s deploy block (speeds scans a lot)
const START_BLOCK_ENV = (() => {
  const v = process.env.NEXT_PUBLIC_COOKIE_START_BLOCK;
  if (!v) return null;
  const n = BigInt(v);
  return n >= 0n ? n : null;
})();

// RPC caps eth_getLogs at 100 blocks → use 96 per call
const STEP = 96n;

// Cast ABI properly (avoid `any`)
const cookieAbi = rawAbi as Abi;

// Typed events (no more args/TS issues)
const EVENT_CookieMinted = parseAbiItem(
  'event CookieMinted(address indexed minter, uint256 indexed tokenId)'
);
const EVENT_Transfer = parseAbiItem(
  'event Transfer(address indexed from, address indexed to, uint256 indexed tokenId)'
);

// Helpers
type MintRow = { tokenId: bigint };
const explorerUrlFor = (tokenId: bigint | string) =>
  `https://testnet.monadexplorer.com/nft/${CONTRACT}/${tokenId.toString()}`;

export default function Page() {
  const { address, chain, status } = useAccount();
  const { data: walletClient } = useWalletClient();
  const pc = usePublicClient();

  // Form
  const [topic, setTopic] = useState('');
  const [vibe, setVibe] = useState('optimistic');
  const [name, setName] = useState('');
  const [fortune, setFortune] = useState('');
  const [genLoading, setGenLoading] = useState(false);
  const [mintLoading, setMintLoading] = useState(false);

  // Status
  const isConnected = status === 'connected' && !!address;
  const onCorrectNetwork = chain?.id === monadTestnet.id;
  function humanStatus(): { text: string; tone: 'ok' | 'warn' | 'err' } {
    if (!isConnected) return { text: 'Disconnected', tone: 'warn' };
    if (!onCorrectNetwork) return { text: `Wrong network — switch to Monad Testnet (${monadTestnet.id})`, tone: 'err' };
    if (!walletClient) return { text: 'Connected (read-only). Open wallet to enable mint.', tone: 'warn' };
    return { text: 'Connected and ready', tone: 'ok' };
  }
  const st = humanStatus();
  const badgeStyle: React.CSSProperties = {
    display: 'inline-block', padding: '2px 8px', borderRadius: 8, fontSize: 12, fontWeight: 600,
    background: st.tone === 'ok' ? '#e6ffed' : st.tone === 'warn' ? '#fffbe6' : '#ffecec',
    color: st.tone === 'ok' ? '#056d2b' : st.tone === 'warn' ? '#7a5b00' : '#8a0012',
  };

  // Data
  const [lastToken, setLastToken] = useState<bigint | null>(null);
  const [minted, setMinted] = useState<MintRow[]>([]);
  const [fetchNote, setFetchNote] = useState<string>('');
  const [lastScanError, setLastScanError] = useState<string>('');

  // Debug toggle (?debug=1 → persists)
  const [debug, setDebug] = useState(false);
  useEffect(() => {
    try {
      const q = new URLSearchParams(window.location.search);
      if (q.get('debug') === '1') localStorage.setItem('cookieDebug', '1');
      setDebug(localStorage.getItem('cookieDebug') === '1');
    } catch {}
  }, []);
  const dbg = (...args: any[]) => { if (debug) console.log('[cookies]', ...args); };

  // Keys (scoped)
  const lastLsKey = useMemo(() => {
    const cid = chain?.id ?? 0;
    const addr = address ?? '0x0';
    return `lastToken:${cid}:${CONTRACT}:${addr}`;
  }, [chain?.id, address]);

  const allLsKey = useMemo(() => {
    const cid = chain?.id ?? 0;
    const addr = address ?? '0x0';
    return `allMintedByMe:${cid}:${CONTRACT}:${addr}`;
  }, [chain?.id, address]);

  const deployLsKey = useMemo(() => `deployBlock:${CONTRACT}`, []);
  const scannedUpToKey = useMemo(() => {
    const cid = chain?.id ?? 0; const addr = address ?? '0x0';
    return `scannedUpTo:${cid}:${CONTRACT}:${addr}`;
  }, [chain?.id, address]);

  // Cache helpers
  function saveLast(tokenId: bigint) {
    if (typeof window === 'undefined') return;
    try { localStorage.setItem(lastLsKey, tokenId.toString()); localStorage.setItem('lastToken:lastUsed', lastLsKey); } catch {}
  }
  function saveAll(rows: MintRow[]) {
    if (typeof window === 'undefined') return;
    try {
      localStorage.setItem(allLsKey, JSON.stringify(rows.map(r => ({ tokenId: r.tokenId.toString() }))));
      localStorage.setItem('allMinted:lastUsed', allLsKey);
    } catch {}
  }
  function clearCachesForContract() {
    if (typeof window === 'undefined') return;
    try {
      const del: string[] = [];
      for (let i = 0; i < localStorage.length; i++) {
        const k = localStorage.key(i) || '';
        if (k.includes(`:${CONTRACT}:`) && (k.startsWith('lastToken:') || k.startsWith('allMintedByMe:') || k.startsWith('scannedUpTo:'))) del.push(k);
      }
      del.forEach(k => localStorage.removeItem(k));
      localStorage.removeItem('lastToken:lastUsed');
      localStorage.removeItem('allMinted:lastUsed');
      localStorage.removeItem(deployLsKey);
    } catch {}
  }

  // Restore caches (also when disconnected)
  useEffect(() => {
    if (typeof window === 'undefined') return;

    const savedLast = localStorage.getItem(lastLsKey) ?? localStorage.getItem(localStorage.getItem('lastToken:lastUsed') || '');
    if (savedLast) { try { setLastToken(BigInt(savedLast)); } catch {} }

    const rawAll = localStorage.getItem(allLsKey) ?? localStorage.getItem(localStorage.getItem('allMinted:lastUsed') || '');
    if (rawAll) {
      try { const parsed = JSON.parse(rawAll) as { tokenId: string }[]; if (Array.isArray(parsed)) setMinted(parsed.map(x => ({ tokenId: BigInt(x.tokenId) }))); } catch {}
    }
  }, [lastLsKey, allLsKey]);

  useEffect(() => { if (lastToken !== null) saveLast(lastToken); }, [lastToken]); // eslint-disable-line
  useEffect(() => { if (minted.length) saveAll(minted); }, [minted]); // eslint-disable-line

  // Clear on disconnect + update status immediately
  const prevStatus = useRef(status);
  useEffect(() => {
    if (prevStatus.current !== status && status !== 'connected') {
      setLastToken(null);
      setMinted([]);
      clearCachesForContract();
    }
    prevStatus.current = status;
  }, [status]);

  // Find deploy/start block (env → cache → discover via getBytecode)
  async function findStartBlock(): Promise<bigint> {
    if (!pc) return 0n;
    if (START_BLOCK_ENV !== null) { dbg('start block (env):', START_BLOCK_ENV.toString()); return START_BLOCK_ENV; }
    try { const cached = localStorage.getItem(deployLsKey); if (cached) { dbg('start block (cached):', cached); return BigInt(cached); } } catch {}
    try {
      const latest = await pc.getBlockNumber();
      const codeLatest = await pc.getBytecode({ address: CONTRACT, blockNumber: latest });
      if (!codeLatest || codeLatest === '0x') return 0n;
      let lo = 0n, hi = latest;
      while (lo + 1n < hi) {
        const mid = lo + (hi - lo) / 2n;
        const code = await pc.getBytecode({ address: CONTRACT, blockNumber: mid });
        if (!code || code === '0x') lo = mid; else hi = mid;
      }
      try { localStorage.setItem(deployLsKey, hi.toString()); } catch {}
      dbg('start block (discovered):', hi.toString());
      return hi;
    } catch { return 0n; }
  }

  // Lightweight “Last minted” if not known yet (short lookback)
  useEffect(() => {
    (async () => {
      if (!pc || !address || chain?.id !== monadTestnet.id) return;
      if (lastToken !== null) return;
      try {
        const latest = await pc.getBlockNumber();
        const fromBlock = latest > 200_000n ? latest - 200_000n : 0n;

        // Try CookieMinted(minter=address)
        try {
          const cmLogs = await pc.getLogs({
            address: CONTRACT,
            event: EVENT_CookieMinted,
            args: { minter: address as `0x${string}` },
            fromBlock,
            toBlock: latest,
          });
          if (cmLogs.length) { setLastToken(cmLogs[cmLogs.length - 1].args.tokenId as bigint); return; }
        } catch {}

        // Fallback: last Transfer to me
        try {
          const tLogs = await pc.getLogs({
            address: CONTRACT,
            event: EVENT_Transfer,
            args: { to: address as `0x${string}` },
            fromBlock,
            toBlock: latest,
          });
          if (tLogs.length) { setLastToken(tLogs[tLogs.length - 1].args.tokenId as bigint); return; }
        } catch {}
      } catch {}
    })();
  }, [pc, address, chain?.id, lastToken]);

  // Fast scanner: ONLY CookieMinted(minter=me), honoring 100-block limit
  async function scanAllMintsByMinter() {
    if (!pc || !address || chain?.id !== monadTestnet.id) return;
    setLastScanError('');
    setFetchNote('scanning my mints…');

    try {
      const latest = await pc.getBlockNumber();
      const startBlock = await findStartBlock();

      // incremental resume
      let from = startBlock;
      try {
        const resume = localStorage.getItem(scannedUpToKey);
        if (resume) {
          const n = BigInt(resume);
          if (n >= startBlock && n <= latest) from = n + 1n;
        }
      } catch {}

      const found: bigint[] = [];
      const existing = new Set(minted.map(m => m.tokenId.toString())); // dedupe with cache
      const sleep = (ms: number) => new Promise(r => setTimeout(r, ms));

      while (from <= latest) {
        const to = from + STEP > latest ? latest : from + STEP;
        const t0 = performance.now();
        dbg('CookieMinted getLogs:', { from: from.toString(), to: to.toString() });

        try {
          const logs = await pc.getLogs({
            address: CONTRACT,
            event: EVENT_CookieMinted,
            args: { minter: address as `0x${string}` },
            fromBlock: from,
            toBlock: to,
          });

          logs.forEach(({ args }) => {
            const id = args.tokenId as bigint;
            if (!existing.has(id.toString())) { existing.add(id.toString()); found.push(id); }
          });

          dbg(`✓ ${logs.length} in ${(performance.now() - t0).toFixed(0)}ms`);
          from = to + 1n;
          localStorage.setItem(scannedUpToKey, to.toString());
          await sleep(60); // be kind to the RPC
        } catch (e: any) {
          const msg = e?.shortMessage || e?.message || String(e);
          dbg('✗ CookieMinted getLogs error:', msg);
          setLastScanError(msg);

          // brief backoff then one retry for the same window
          await sleep(200);
          const logs = await pc.getLogs({
            address: CONTRACT,
            event: EVENT_CookieMinted,
            args: { minter: address as `0x${string}` },
            fromBlock: from,
            toBlock: to,
          });
          logs.forEach(({ args }) => {
            const id = args.tokenId as bigint;
            if (!existing.has(id.toString())) { existing.add(id.toString()); found.push(id); }
          });
          from = to + 1n;
          localStorage.setItem(scannedUpToKey, to.toString());
          await sleep(60);
        }
      }

      if (found.length) {
        const rows = [...minted, ...found.map(tokenId => ({ tokenId }))]
          .sort((a, b) => (a.tokenId < b.tokenId ? -1 : 1));
        setMinted(rows);
        setFetchNote(`via CookieMinted(minter=me) • ${rows.length} total`);
      } else {
        setFetchNote('no CookieMinted events for this wallet');
      }
    } catch (e) {
      setFetchNote('scan failed (cache shown if available)');
      console.warn('my-mints scan failed:', e);
    }
  }

  // Kick scans when connected & on correct network
  useEffect(() => {
    if (isConnected && onCorrectNetwork) scanAllMintsByMinter();
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [isConnected, onCorrectNetwork, address, chain?.id]);

  // Actions
  async function generateFortune() {
    setGenLoading(true);
    try {
      const res = await fetch('/api/fortune', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ topic, vibe, name }),
      });
      const j = await res.json();
      if (!res.ok) throw new Error(j.error || 'AI failed');
      setFortune((j.fortune || '').toString());
    } catch (e: any) {
      alert(e?.message || 'Failed to generate fortune');
    } finally {
      setGenLoading(false);
    }
  }

  async function mint() {
    if (!walletClient || chain?.id !== monadTestnet.id) {
      alert(`Connect wallet on Monad Testnet (${monadTestnet.id})`);
      return;
    }
    if (!fortune) {
      alert('Generate a fortune first');
      return;
    }

    setMintLoading(true);
    setLastToken(null);

    try {
      const hash = await walletClient.writeContract({
        address: CONTRACT,
        abi: cookieAbi,
        functionName: 'mintWithFortune',
        args: [fortune],
        chain: monadTestnet, // keep if this matches your working setup; remove if TS complains
        account: address as `0x${string}`,
      });

      if (!pc) throw new Error('Public client not available');
      const receipt = await pc.waitForTransactionReceipt({ hash });

      // Prefer CookieMinted in the receipt
      const ev = parseEventLogs({ abi: cookieAbi, logs: receipt.logs, eventName: 'CookieMinted' });
      if (ev.length) {
        const tokenId = (ev[0] as any).args.tokenId as bigint;
        setLastToken(tokenId);
      } else {
        // Fallback: last Transfer
        const tEv = parseEventLogs({ abi: [EVENT_Transfer], logs: receipt.logs, eventName: 'Transfer' });
        if (tEv.length) setLastToken((tEv[tEv.length - 1] as any).args.tokenId as bigint);
      }

      // Nudge my-mints scan
      setTimeout(() => { scanAllMintsByMinter(); }, 300);
    } catch (e: any) {
      alert(e?.shortMessage || e?.message || 'Mint failed');
    } finally {
      setMintLoading(false);
    }
  }

  // UI helpers
  const shortAddr = address ? `${address.slice(0, 6)}…${address.slice(-4)}` : '—';
  const explorerUrl = lastToken != null ? explorerUrlFor(lastToken) : null;
  const shareUrl = lastToken != null && explorerUrl
    ? `https://x.com/intent/tweet?text=${encodeURIComponent(`I just minted COOKIE #${lastToken.toString()} on Monad Testnet!`)}&url=${encodeURIComponent(explorerUrl)}`
    : null;

  return (
    <div className="container">
      {/* header */}
      <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', alignItems: 'center', marginBottom: 10 }}>
        <div />
        <div style={{ display: 'flex', justifyContent: 'flex-end' }}>
          <ConnectButton />
        </div>
      </div>

      <div className="row">
        {/* Left: form */}
        <div className="card" style={{ flex: '1 1 420px' }}>
          <label>Topic / hint</label>
          <input className="input" value={topic} onChange={(e) => setTopic(e.target.value)} placeholder="e.g., gas efficiency, launch day, testnet" />

          <div style={{ display: 'grid', gridTemplateColumns: '1fr 1fr', gap: 12, marginTop: 12 }}>
            <div>
              <label>Vibe</label>
              <input className="input" value={vibe} onChange={(e) => setVibe(e.target.value)} placeholder="optimistic, playful, zen…" />
            </div>
            <div>
              <label>Name (optional)</label>
              <input className="input" value={name} onChange={(e) => setName(e.target.value)} placeholder="your name/team" />
            </div>
          </div>

          <div style={{ marginTop: 12 }}>
            <button className="button" onClick={generateFortune} disabled={genLoading}>
              {genLoading ? 'Generating…' : 'Generate with AI'}
            </button>
          </div>

          <div style={{ marginTop: 10 }}>
            <label>Fortune (preview)</label>
            <textarea className="input" rows={3} value={fortune} onChange={(e) => setFortune(e.target.value)} />
            <div className="small" style={{ marginTop: 6 }}>Tip: keep under ~160 chars (contract allows up to 240 bytes).</div>
          </div>

          <div style={{ marginTop: 12 }}>
            <button className="button" onClick={mint} disabled={mintLoading || !fortune || !onCorrectNetwork || !isConnected}>
              {mintLoading ? 'Minting…' : 'Mint This Fortune'}
            </button>
          </div>
        </div>

        {/* Right: status + LAST + ALL (minter-only) */}
        <div className="card" style={{ flex: '1 1 380px' }}>
          <div className="small">Status</div>
          <div style={{ marginBottom: 6 }}><span style={badgeStyle}>{st.text}</span></div>
          <div>Network: <b>{chain?.name || '—'}</b></div>
          <div>Address: <b>{shortAddr}</b></div>

          <div style={{ marginTop: 12 }} className="small">Last minted</div>
          <div>
            {lastToken ? (
              <>
                COOKIE #{lastToken.toString()}
                {explorerUrl && (
                  <>
                    {' '}•{' '}
                    <a target="_blank" rel="noreferrer" href={explorerUrl}>view</a>
                    {' '}•{' '}
                    <a target="_blank" rel="noreferrer" href={shareUrl!}>share on X</a>
                  </>
                )}
              </>
            ) : '—'}
          </div>

          <div style={{ marginTop: 16 }} className="small">
            All minted to this wallet {fetchNote ? <em style={{ opacity: 0.6 }}> • {fetchNote}</em> : null}
          </div>
          <div>
            {minted.length ? (
              <ul style={{ paddingLeft: 18, marginTop: 6 }}>
                {minted.map((m) => {
                  const url = explorerUrlFor(m.tokenId);
                  const x = `https://x.com/intent/tweet?text=${encodeURIComponent(
                    `I minted COOKIE #${m.tokenId.toString()} on Monad Testnet!`
                  )}&url=${encodeURIComponent(url)}`;
                  return (
                    <li key={m.tokenId.toString()} style={{ marginBottom: 10 }}>
                      COOKIE #{m.tokenId.toString()} •{' '}
                      <a target="_blank" rel="noreferrer" href={url}>view</a>
                      {' '}•{' '}
                      <a target="_blank" rel="noreferrer" href={x}>share on X</a>
                    </li>
                  );
                })}
              </ul>
            ) : <div>—</div>}
          </div>

          {debug && (
            <>
              <div style={{ marginTop: 8 }}>
                <button className="button" style={{ padding: '2px 8px', fontSize: 12 }} onClick={scanAllMintsByMinter}>
                  Rescan (debug)
                </button>
              </div>
              {lastScanError && (
                <div style={{ marginTop: 8, fontSize: 12, opacity: 0.75 }}>
                  last error: {lastScanError}
                </div>
              )}
            </>
          )}
        </div>
      </div>
    </div>
  );
}
